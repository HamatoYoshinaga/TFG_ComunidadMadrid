INICIO

    // --- 1. Cargar resultados de distancias calculadas ---
    LEER DataFrame_Distancias DESDE archivo_resultados_API
    
    // --- 2. Cargar diccionarios de clasificación ---
    LEER Diccionario_Referencias DESDE archivo_coordenadas_referencias
    LEER Diccionario_Servicios_Tipo1 DESDE archivo_coordenadas_tipo1
    LEER Diccionario_Servicios_Tipo2 DESDE archivo_coordenadas_tipo2
    LEER Diccionario_Servicios_TipoN DESDE archivo_coordenadas_tipoN

    // --- 3. Clasificar destinos por tipo de servicio ---
    FUNCIÓN ClasificarDestino(id_destino)
        SI id_destino EXISTE EN Diccionario_Servicios_Tipo1 ENTONCES
            DEVOLVER "tipo_servicio_1"
        SINO SI id_destino EXISTE EN Diccionario_Servicios_Tipo2 ENTONCES
            DEVOLVER "tipo_servicio_2"
        SINO SI id_destino EXISTE EN Diccionario_Servicios_TipoN ENTONCES
            DEVOLVER "tipo_servicio_N"
        SINO SI id_destino EXISTE EN Diccionario_Referencias ENTONCES
            DEVOLVER "referencia"
        SINO
            DEVOLVER NULO
        FIN SI
    FIN FUNCIÓN

    // Aplicar clasificación a todas las filas
    DataFrame_Distancias["tipo_destino"] ← APLICAR ClasificarDestino A DataFrame_Distancias["destino"]

    // --- 4. Calcular métricas agregadas por ubicación ---
    DataFrame_Metricas_Agregadas ← AGRUPAR DataFrame_Distancias POR [origen, modo_transporte, tipo_destino]
    DataFrame_Metricas_Agregadas ← CALCULAR_PROMEDIO DE [distancia_metros, duracion_segundos]

    // --- 5. Transformar a formato pivotado ---
    FUNCIÓN TransformarMetrica(metrica)
        DEVOLVER TABLA_PIVOTE(
            indice: "origen",
            columnas: [tipo_destino, modo_transporte],
            valores: metrica,
            valor_relleno: 0
        )
    FIN FUNCIÓN

    DataFrame_Duraciones ← TransformarMetrica("duracion_segundos")
    DataFrame_Distancias_Pivot ← TransformarMetrica("distancia_metros")

    // Aplanar nombres de columnas
    DataFrame_Duraciones.columnas ← GENERAR ["duracion_s_" + tipo_destino + "_" + modo_transporte]
    DataFrame_Distancias_Pivot.columnas ← GENERAR ["distancia_m_" + tipo_destino + "_" + modo_transporte]

    // Combinar dataframes
    DataFrame_Unificado ← CONCATENAR [DataFrame_Duraciones, DataFrame_Distancias_Pivot] POR columnas
    DataFrame_Unificado ← REINICIAR_INDICE(DataFrame_Unificado)
    DataFrame_Unificado ← RENOMBRAR columna "origen" A "id_ubicacion"

    // --- 6. Procesar datos geoespaciales ---
    LEER GeoDataFrame_Ubicaciones DESDE archivo_geometrias_principales
    
    // Aplicar filtros espaciales
    APLICAR_FILTROS_CRITERIO A GeoDataFrame_Ubicaciones
    CONVERTIR GeoDataFrame_Ubicaciones A sistema_coordenadas_web_mercator
    
    // Extraer identificadores jerárquicos si aplica
    SI EXISTE jerarquia_administrativa ENTONCES
        GeoDataFrame_Ubicaciones["id_region"] ← EXTRAER_ID_REGION(GeoDataFrame_Ubicaciones["id_ubicacion"])
    FIN SI

    // --- 7. Crear dataset agregado por región ---
    SI EXISTE jerarquia_administrativa ENTONCES
        // Agregar métricas por región
        DataFrame_Distancias["id_region"] ← EXTRAER_ID_REGION(DataFrame_Distancias["origen"])
        
        DataFrame_Metricas_Region ← AGRUPAR DataFrame_Distancias POR [id_region, modo_transporte, tipo_destino]
        DataFrame_Metricas_Region ← CALCULAR_PROMEDIO DE [distancia_metros, duracion_segundos]
        
        // Transformar a formato pivotado para regiones
        DataFrame_Duraciones_Region ← TransformarMetrica("duracion_segundos") CON indice "id_region"
        DataFrame_Distancias_Region ← TransformarMetrica("distancia_metros") CON indice "id_region"
        
        // Combinar datos de región
        DataFrame_Region_Unificado ← CONCATENAR [DataFrame_Duraciones_Region, DataFrame_Distancias_Region]
        DataFrame_Region_Unificado ← REINICIAR_INDICE(DataFrame_Region_Unificado)
    FIN SI

    // --- 8. Crear sistema de puntuación compuesta ---
    DEFINIR pesos_servicios ← {
        "tipo_servicio_1": peso_alto,
        "tipo_servicio_2": peso_medio,
        "tipo_servicio_3": peso_bajo
    }

    DEFINIR pesos_alternativos ← CONFIGURACIONES_PESOS_ALTERNATIVOS()

    FUNCIÓN NormalizarMetrica(valor, min_valor, max_valor)
        SI valor ES NULO ENTONCES
            DEVOLVER NULO
        FIN SI
        DEVOLVER (valor - min_valor) / (max_valor - min_valor)
    FIN FUNCIÓN

    FUNCIÓN EliminarOutliers(serie_temporal)
        Q1 ← CALCULAR_CUARTIL(serie_temporal, 0.25)
        Q3 ← CALCULAR_CUARTIL(serie_temporal, 0.75)
        IQR ← Q3 - Q1
        
        limite_inferior ← Q1 - 1.5 * IQR
        limite_superior ← Q3 + 1.5 * IQR
        
        DEVOLVER RECORTAR(serie_temporal, limite_inferior, limite_superior)
    FIN FUNCIÓN

    // Normalizar métricas
    PARA CADA modo_transporte EN modos_transporte HACER
        PARA CADA tipo_servicio EN tipos_servicios HACER
            columna ← "duracion_s_" + tipo_servicio + "_" + modo_transporte
            serie_limpia ← EliminarOutliers(DataFrame_Unificado[columna])
            min_valor ← MINIMO(serie_limpia)
            max_valor ← MAXIMO(serie_limpia)
            
            DataFrame_Unificado[columna + "_norm"] ← APLICAR NormalizarMetrica CON parametros(min_valor, max_valor)
        FIN PARA
    FIN PARA

    FUNCIÓN CalcularPuntuacion(fila, modo_transporte)
        puntuacion ← 0
        pesos_aplicables ← DETERMINAR_PESOS_SEGUN_DISPONIBILIDAD(fila, pesos_servicios, pesos_alternativos)
        
        PARA CADA tipo_servicio, peso EN pesos_aplicables HACER
            columna_normalizada ← "duracion_s_" + tipo_servicio + "_" + modo_transporte + "_norm"
            SI fila[columna_normalizada] NO ES NULO ENTONCES
                puntuacion ← puntuacion + fila[columna_normalizada] * peso
            FIN SI
        FIN PARA
        
        // Invertir puntuación (mayor puntuación = mejor accesibilidad)
        DEVOLVER 1 - puntuacion
    FIN FUNCIÓN

    // Calcular puntuaciones
    PARA CADA modo_transporte EN modos_transporte HACER
        columna_puntuacion ← "puntuacion_accesibilidad_" + modo_transporte
        DataFrame_Unificado[columna_puntuacion] ← APLICAR CalcularPuntuacion CON parametro(modo_transporte)
    FIN PARA

    // --- 9. Establecer relaciones jerárquicas ---
    SI EXISTE jerarquia_administrativa ENTONCES
        // Relaciones ubicación → región
        GeoDataFrame_Ubicaciones["id_region"] ← EXTRAER_ID_REGION(GeoDataFrame_Ubicaciones["id_ubicacion"])
        
        // Relaciones región → ubicaciones
        FUNCIÓN ObtenerUbicacionesEnRegion(id_region)
            DEVOLVER LISTA(GeoDataFrame_Ubicaciones DONDE id_region = id_region)["id_ubicacion"]
        FIN FUNCIÓN
        
        GeoDataFrame_Regiones["ubicaciones_contenidas"] ← APLICAR ObtenerUbicacionesEnRegion A GeoDataFrame_Regiones["id_region"]
    FIN SI

    // --- 10. Unir datos geoespaciales con métricas ---
    GeoDataFrame_Final_Ubicaciones ← UNIR GeoDataFrame_Ubicaciones CON DataFrame_Unificado POR "id_ubicacion"
    
    SI EXISTE jerarquia_administrativa ENTONCES
        GeoDataFrame_Final_Regiones ← UNIR GeoDataFrame_Regiones CON DataFrame_Region_Unificado POR "id_region"
    FIN SI

    // --- 11. Generar archivos de salida para visualización ---
    FUNCIÓN CrearFeatureGeoJSON(geometria, propiedades)
        DEVOLVER {
            "tipo": "Feature",
            "geometria": CONVERTIR_A_GEOJSON(geometria),
            "propiedades": propiedades
        }
    FIN FUNCIÓN

    // Crear features para ubicaciones
    lista_features_ubicaciones ← LISTA_VACIA
    PARA CADA fila EN GeoDataFrame_Final_Ubicaciones HACER
        propiedades ← {
            "id": fila.id_ubicacion,
            "nombre": fila.nombre,
            "id_region": fila.id_region,
            // Métricas de tiempo por servicio y modo de transporte
            PARA CADA combinacion_servicio_modo: fila[metrica_correspondiente],
            // Puntuaciones de accesibilidad
            PARA CADA modo_transporte: fila["puntuacion_accesibilidad_" + modo_transporte]
        }
        
        AÑADIR CrearFeatureGeoJSON(fila.geometria, propiedades) A lista_features_ubicaciones
    FIN PARA

    // Crear features para regiones si aplica
    SI EXISTE jerarquia_administrativa ENTONCES
        lista_features_regiones ← LISTA_VACIA
        PARA CADA fila EN GeoDataFrame_Final_Regiones HACER
            propiedades_region ← {
                "id": fila.id_region,
                "nombre": fila.nombre,
                "ubicaciones_contenidas": fila.ubicaciones_contenidas,
                // Métricas agregadas por servicio y modo
                PARA CADA metrica_agregada: fila[metrica_correspondiente],
                // Puntuaciones regionales
                PARA CADA modo_transporte: fila["puntuacion_accesibilidad_" + modo_transporte]
            }
            
            AÑADIR CrearFeatureGeoJSON(fila.geometria, propiedades_region) A lista_features_regiones
        FIN PARA
    FIN SI

    // --- 12. Exportar archivos finales ---
    archivo_ubicaciones ← {
        "tipo": "FeatureCollection",
        "features": lista_features_ubicaciones
    }
    
    GUARDAR archivo_ubicaciones EN "datos_ubicaciones_finales.geojson"
    
    SI EXISTE jerarquia_administrativa ENTONCES
        archivo_regiones ← {
            "tipo": "FeatureCollection", 
            "features": lista_features_regiones
        }
        GUARDAR archivo_regiones EN "datos_regiones_finales.geojson"
    FIN SI

    IMPRIMIR "Archivos GeoJSON generados exitosamente para visualización web"

FIN

// --- ESTRUCTURA DE ARCHIVOS DE SALIDA ---

datos_ubicaciones_finales.geojson:
{
    "tipo": "FeatureCollection",
    "features": [
        {
            "tipo": "Feature",
            "geometria": {...},
            "propiedades": {
                "id": "ubicacion_001",
                "nombre": "Nombre_Ubicacion",
                "id_region": "region_001",
                "duracion_s_servicio1_modo1": valor,
                "duracion_s_servicio1_modo2": valor,
                "duracion_s_servicio2_modo1": valor,
                "puntuacion_accesibilidad_modo1": valor,
                "puntuacion_accesibilidad_modo2": valor
            }
        },
        ...
    ]
}

datos_regiones_finales.geojson:
{
    "tipo": "FeatureCollection",
    "features": [
        {
            "tipo": "Feature", 
            "geometria": {...},
            "propiedades": {
                "id": "region_001",
                "nombre": "Nombre_Region",
                "ubicaciones_contenidas": ["ubicacion_001", "ubicacion_002"],
                "duracion_s_servicio1_modo1": valor_promedio,
                "duracion_s_servicio1_modo2": valor_promedio,
                "puntuacion_accesibilidad_modo1": valor_promedio,
                "puntuacion_accesibilidad_modo2": valor_promedio
            }
        },
        ...
    ]
}